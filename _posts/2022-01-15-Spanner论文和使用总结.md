---
layout: post
title:  "Spanner论文和使用小结"
date:   2022-01-16 10:00:00 -0000
categories: 技术
tags:  
---


这个月又继续恢复上MIT的[Distributed System](http://nil.csail.mit.edu/6.824/2020/schedule.html)的课， 上次上刚好是一年前。这次感受跟上次有些不同，就是心更沉静了，读paper上课变得比较容易。日本一月有很多假，放假的日子里我几乎每天都到咖啡店，看一篇论文然后上一堂课，差不多花4，5个小时。

刚刚上完了讲Spanner的课程，其实项目中正好有用到。Spanner核心是两个点：

1. 基于Paxos的Two-phase commit的写。用分布式的Paxos保证Two-phase commit的各个participant 的可用性。同时使用Truetime api保证commit一定发生在过去。

2. 读是基于Truetime的Snapshot读。赋给读一个timestamp，然后保证这个timestamp能见到所有之前的commit。

Truetime的概念也非常有意思。在分布式的世界里，有一个比较核心的问题就是**处理共识**。比方说RAFT用多数选举的方法来保证一个leader，然后所有instance都听从leader的指令，共识问题简化成确认谁是leader。而Truetime要处理的问题就是不同机器对时间的共识。首先说时间是一个天然的共识，有一个标准时间（来自国家实验室），然后其他人使用的时间都是尽量在向这个标准时间靠拢。有了这个共识，我们就可以用来决定事件发生的先后顺序。在Spanner的例子里，解决的是读和写在commit写之后的问题。

每台机器的时间，不可避免都要都误差，因为校准时间有间隔，然后请求有延迟。Truetime的核心是返回一个时间范围，可以保证当前时间一定在这个范围内（根据google的论文比cpu出错的概率低4倍），如果两个时间范围不重叠，那么一定可以保证其顺序。
```
t1 < e1 < t2 and t3 < e2 < t4
if t2 < ts -> e1 < e2
if t1 > t4 -> e1 > e2
```

然后我们在一个范围内只做一个写事件，下个事件一定要等到下个时间范围（waiting out the uncertainty）。（写事件在一个时间范围，当这个范围的最大值，小于下个时间范围的最小值）。 这样我们就可以利用Truetime API 保证了一系列事件的顺序。

如果能保证事件发生的序列，那分布式系统就可以在外部看起来像一个单机单线程的系统了，也就是保证了external consistency或者linearizability。像[RAFT](http://nil.csail.mit.edu/6.824/2020/papers/raft-extended.pdf)也可以保证事件发生的序列，但是各个节点分布在各个data center的时候，交流可能需要很久。replica需要通过leader的信息才能知道他能不能处理一个读信息。而Spanner的Truetime是很cheap的操作，他可以在loacl就能决定哪些数据是可以读的，哪些是不能读的。

项目上目前正在Data migration，把老系统Mysql的数据移动到Spanner上，发现write Transaction操作的性能不是很好，每秒3000 write ops，延迟在50ms ～ 100ms左右，数据量是billion级。很容易理解，因为Spanner是一个需要写多数replica的分布式Two-phase commit写，所以相比single instance有额外的延迟。

再写写Two-phase commit。每一个transaction会有一个transaction coordinator（TC）， 然后transaction participants（TP）。transaction coordinator 是transaction commit or abort的决定者。第一个阶段，TC会发prepare消息到各个TP，然后等待TP回复是否准备好了执行transaction。如果有no， TC就会abort transaction。 如果都回复yes， TC就先会持久化决定，然后把决定告诉所有TP，（TP的回复相当于一种承诺，如果yes就要一定做到）， 然后TC会等所有TC回复ack的消息，不然会一直重新发送决定。而TP接受到决定以后，就要保证写一定要完成。

所以在Two-phase commit 里，有多个环节都是要blocking等待的，如果任一参与者TP 或 TC shut down了，系统就blocking。 而Spanner这里，每一个TP or TC 都是Paxos的group， 可以提高他们的可用性，防止其中一个instance挂掉。


